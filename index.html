<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Geo Direction AR</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.4);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 18px;
    }
  </style>
</head>
<body>
<div id="hud">
  <div>Heading: <span id="heading">0</span>Â°</div>
  <div>Direction: <span id="dir">N</span></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
let camera, scene, renderer, arrow;
let targetCoords = { lat: 13.0827, lon: 80.2707 }; // ðŸŽ¯ Chennai example
let headingDisplay = document.getElementById('heading');
let dirDisplay = document.getElementById('dir');

// Convert degrees to radians
function toRad(deg) { return deg * Math.PI / 180; }
function toDeg(rad) { return rad * 180 / Math.PI; }

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
  renderer = new THREE.WebGLRenderer({ alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // 3D Arrow pointing in Z direction
  const geometry = new THREE.ConeGeometry(0.5, 1.5, 32);
  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  arrow = new THREE.Mesh(geometry, material);
  arrow.rotation.x = Math.PI; // point forward
  scene.add(arrow);

  camera.position.set(0, 0, 0);
  animate();
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

// Compute bearing from current GPS to target GPS
function bearingToTarget(lat1, lon1, lat2, lon2) {
  const Ï†1 = toRad(lat1);
  const Ï†2 = toRad(lat2);
  const Î”Î» = toRad(lon2 - lon1);
  const y = Math.sin(Î”Î») * Math.cos(Ï†2);
  const x = Math.cos(Ï†1)*Math.sin(Ï†2) - Math.sin(Ï†1)*Math.cos(Ï†2)*Math.cos(Î”Î»);
  let Î¸ = Math.atan2(y, x);
  return (toDeg(Î¸) + 360) % 360; // 0â€“360Â°
}

// Convert heading to compass name
function compassName(deg) {
  const dirs = ['N','NE','E','SE','S','SW','W','NW','N'];
  return dirs[Math.round(deg / 45)];
}

let currentBearing = 0;

function updatePosition(pos) {
  const lat = pos.coords.latitude;
  const lon = pos.coords.longitude;
  currentBearing = bearingToTarget(lat, lon, targetCoords.lat, targetCoords.lon);
}

// Update arrow direction and HUD
function handleOrientation(e) {
  let heading = e.webkitCompassHeading || (360 - e.alpha); // iOS or Android
  if (heading < 0) heading += 360;
  headingDisplay.textContent = heading.toFixed(0);
  dirDisplay.textContent = compassName(heading);

  // Rotate arrow toward target direction
  let diff = currentBearing - heading;
  arrow.rotation.y = toRad(diff);
}

if (navigator.geolocation) {
  navigator.geolocation.watchPosition(updatePosition);
}
window.addEventListener('deviceorientationabsolute', handleOrientation, true);
window.addEventListener('deviceorientation', handleOrientation, true);

init();
</script>
</body>
</html>
